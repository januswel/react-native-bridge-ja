Bridging in React Native
========================

On this post I assume you know the basics of React Native, and will focus on how the internals work when managing the communication between native and JavaScript.

Main Threads
------------

Before anything else, keep in mind that there are 3 "main" threads[^1] in React Native:

- The shadow queue: where the layout happens
- The main thread: where UIKit does its thing
- The JavaScript thread: where your JS code is actually running

Plus every native module has its own [GCD](https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html) Queue unless it specifies otherwise (a more detailed explanation is coming).

[^1] The "shadow queue" is actually a GCD Queue rather than a thread, as the name suggests.

Native Modules
--------------

_if you don't know how to create a Native Module yet, I'd recommend you check the documentation before._

Here's an example `Person` native module, that both, receives calls from JavaScript and calls into JS.

```objc
@interface Person : NSObject <RCTBridgeModule>
@end

@implementation Logger

RCT_EXPORT_MODULE()

RCT_EXPORT_METHOD(greet:(NSString *)name)
{
  NSLog(@"Hi, %@!", name);
  [_bridge.eventDispatcher sendAppEventWithName:@"greeted"
                                           body:@{ @"name": name }];
}

@end
```

We are going to focus on these two macros, `RCT_EXPORT_MODULE` and `RCT_EXPORT_METHOD`, what they expand into, what are their roles and how does it work from there.

`RCT_EXPORT_MODULE([js_name])`
------------------------------

As the name suggests, it exports your modules, but what does export mean in this specific context? It means making the bridge aware of your module.

Its definition is actually pretty simple:

```objc
#define RCT_EXPORT_MODULE(js_name) \
  RCT_EXTERN void RCTRegisterModule(Class); \
  + (NSString \*)moduleName { return @#js_name; } \
  + (void)load { RCTRegisterModule(self); }
```

What does it do:

- It first declares `RCTRegisterModule` as an `extern` function, which means that the implementation of the function is not visible to the compiler but will be available at link time, than
- declares a method `moduleName`, that returns the optional macro parameter `js_name`, in case you want your module to have a name in JS other than the Objective-C class name, and last
- declares a `load` method (When the app is loaded into memory it'll call the `load` method for every class) that calls the above declared `RCTRegisterModule` function to actually make the bridge aware of this module.

`RCT_EXPORT_METHOD(method)`
---------------------------

This macro is "more interesting", it doesn't add anything to your actual method, it actually creates a new method in addition to declaring the one specified.

This new method would look something like that for our example:

```objc
+ (NSArray *)__rct_export__120
{
  return @[ @"", @"log:(NSString *)message" ];
}
```

"What the heck is that?" would be a very acceptable first reaction

It's generated by concatenating the prefix (`__rct_export__`) with an optional `js_name` (empty in this case) with the line number of the declartion (e.g. 12) with the [`__COUNTER__`](https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html) macro.

The purpose of this method is only returning an array that contains the optional `js_name` (again, empty in this case) and the method signature. The hack on the name is only to avoid method clashing[^2].

[^2] it's still technically possible to have 2 generated methods with the same name if you're using a category, but very much unlikely and shouldn't result in any expected behaviour, although Xcode will warn you that it has an unexpected behaviour.

Runtime
-------

This whole setup is only to provide information to the bridge, so it can find everything that was exported, modules and methods, but this all happens at load time, now we'll look at how it's used at runtime.

Here's the bridge initialisation dependency graph:

![initialization](images/initialisation.svg)

### Initialise Modules

All the `RCTRegisterModule` function does is add the class to an array so the bridge can find it later when a new bridge instance is created. It goes through the modules array, create an instance of every module, store a reference to it on the bridge, give it a reference back to the bridge (so we can call both ways), and check if it has specified in which `queue` it wants to run, otherwise we give it a new queue, separate from all other modules.

```objc
NSMutableDictionary *modulesByName; // = ...
for (Class moduleClass in RCTGetModuleClasses()) {
  // ...
  module = [moduleClass new];
  if ([module respondsToSelector:@selector(setBridge:)]) {
    module.bridge = self;
  }
  modulesByName[moduleName] = module;
  // ...
}
```

### Configure Modules

Once we have our modules, in a background thread, we list all the methods for each module, and call the methods that begin with `__rct_export__`, so we can have a string representation of the method signature. That's important so we can have the actual types of the parameters, i.e. at runtime we'd only be able to know that a parameter is an `id`, this way we can know that it's actually an `NSString *` in this case.

```objc
unsigned int methodCount;
Method *methods = class_copyMethodList(moduleClass, &methodCount);
for (unsigned int i = 0; i < methodCount; i++) {
  Method method = methods[i];
  SEL selector = method_getName(method);
  if ([NSStringFromSelector(selector) hasPrefix:@"__rct_export__"]) {
    IMP imp = method_getImplementation(method);
    NSArray *entries = ((NSArray *(*)(id, SEL))imp)(_moduleClass, selector);
    //...
    [moduleMethods addObject:/* Object representing the method */];
  }
}
```

### Setup JavaScript Executor

The JavaScript executors have a `-setUp` method that allows it to do more expensive work, like initialising JavaScriptCore, on a background thread. It also saves some work, since only the active executor will receive the `setUp` call, rather than all the executors available.

```objc
JSGlobalContextRef ctx = JSGlobalContextCreate(NULL);
_context = [[RCTJavaScriptContext alloc] initWithJSContext:ctx];
```
